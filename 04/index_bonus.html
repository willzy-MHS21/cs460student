<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">
        <title>Asst4 Bonus</title>
        <style>
            html,
            body {
                background-color: #000;
                margin: 0;
                padding: 0;
                height: 100%;
                overflow: hidden !important;
                background: url('https://cs460.org/assignments/04/bg.jpg');
                background-size: cover;
            }

            #c {
                width: 100%;
                height: 100%;
            }

            #music-toggle {
                position: fixed;
                bottom: 20px;
                left: 20px;
                font-size: 30px;
                cursor: pointer;
                color: white;
                user-select: none;
                z-index: 10;
                transition: transform 0.2s;
            }

            #music-toggle:hover {
                transform: scale(1.2);
            }

            #goback-btn {
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10;
                padding: 10px 20px;
                font-size: 16px;
                font-weight: bold;
                background-color: #ff9800;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
            }

            #goback-btn:hover {
                background-color: #e68900;
            }
        </style>
    </head>

    <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>

    <script id="vertexshader" type="glsl">
        attribute vec3 a_position;
        uniform float u_pointSize;
        uniform mat4 u_transform;

        void main(void) {
            vec4 final_position = u_transform * vec4(a_position, 1.0);
            gl_Position = final_position;
            gl_PointSize = u_pointSize;
        }
    </script>

    <script id="fragmentshader" type="glsl">
        precision mediump float;
        uniform vec4 u_color;

        void main(void) {
            gl_FragColor = u_color;
        }
    </script>

    <script>
        var c, gl;
        var v_shader, f_shader, shaderprogram;
        var vertices, indices, eye_vertex, v_buffer, i_buffer, eye_v_buffer;

        // big fish color
        var bigFishCurrentColor = [1.0, 0.0, 0.0, 0.7]; 
        var bigFishTargetColor = [Math.random(), Math.random(), Math.random(), 0.7];
        var colorChangeSpeed = 0.01;

        // big fish position and rotation
        var keys = {};
        var bigFishOffset = [0, 0, 0];
        var moveSpeed = 0.03;
        var bigFishRotation = 0;
        var rotationSpeed = 0.05;

        window.onload = function () {
            //************************************************************//
            //
            // INITIALIZE WEBGL
            //
            c = document.getElementById('c'); // setup canvas
            c.width = window.innerWidth;
            c.height = window.innerHeight;

            gl = c.getContext('webgl'); // setup GL context
            gl.viewport(0, 0, c.width, c.height);

            //************************************************************//
            //
            // SHADERS
            //
            v_shader = gl.createShader(gl.VERTEX_SHADER);
            f_shader = gl.createShader(gl.FRAGMENT_SHADER);

            // compile vertex shader
            gl.shaderSource(v_shader, document.getElementById('vertexshader').innerText);
            gl.compileShader(v_shader);

            if (!gl.getShaderParameter(v_shader, gl.COMPILE_STATUS)) {
                console.log(gl.getShaderInfoLog(v_shader));
            }

            // compile fragment shader
            gl.shaderSource(f_shader, document.getElementById('fragmentshader').innerText);
            gl.compileShader(f_shader);

            if (!gl.getShaderParameter(f_shader, gl.COMPILE_STATUS)) {
                console.log(gl.getShaderInfoLog(f_shader));
            }

            // attach and link the shaders
            shaderprogram = gl.createProgram();
            gl.attachShader(shaderprogram, v_shader);
            gl.attachShader(shaderprogram, f_shader);

            gl.linkProgram(shaderprogram);

            gl.useProgram(shaderprogram);

            // create multiple rectangles
            all_fish = [];
            all_fish.push(createFish(new Float32Array([0, 0, 0]), new Float32Array([1., 0., 0., 1.]), 1, -1));

            for (let i = 0; i < 100; i++) {
                random_color = [Math.random(),Math.random(),Math.random(),Math.random()];
                random_offset = [Math.random()-Math.random(), Math.random()-Math.random(), 0];
                random_scale = Math.random() * 0.3;
                all_fish.push(createFish(random_offset, random_color, random_scale, 1));
            }

            // keyboard to control movement on the big fish
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // mouse wheel to scale the big fish
            window.addEventListener('wheel', (e) => {
                var scaleChange = 0.05; 
                // index 0 = v_buffer, 1 = i_buffer, 2 = eye, 3 = offset, 4 = color, 5 = scale
                if (e.deltaY < 0) {
                    all_fish[0][5] += scaleChange; 
                    if (all_fish[0][5] > 3.0) {
                        all_fish[0][5] = 3.0; // max scale
                    }
                } else {
                    all_fish[0][5] -= scaleChange;
                    if (all_fish[0][5] < 0.3) {
                        all_fish[0][5] = 0.3; // min scale
                    }
                }
            });

            // background music
            const bgm = document.getElementById('bgm');
            const toggle = document.getElementById('music-toggle');

            toggle.addEventListener('click', () => {
                if (bgm.paused) {
                    bgm.play();
                } else {
                    bgm.pause();
                }
            });

            // navigate back to main page
            document.getElementById('goback-btn').onclick = function() {
                window.location.href = 'index.html';
            };

            animate();
        };


        function createFish(offset, color, scale, direction) {
            //************************************************************//
            //
            // CREATE GEOMETRY
            //
            vertices = new Float32Array([
                0.5, 0.0, 0.0, // 0: nose
                0.2, 0.25, 0.0, // 1: upper body
                -0.2, 0.15, 0.0, // 2: upper tail base
                -0.4, 0.3, 0.0, // 3: upper tail tip
                -0.4, -0.3, 0.0, // 4: lower tail tip
                -0.2, -0.15, 0.0, // 5: lower tail base
                0.2, -0.25, 0.0 // 6: lower body
            ]);

            // now use indices
            indices = new Uint8Array([
                0, 1, 6, // main body
                1, 2, 6, // upper mid-body
                2, 5, 6, // rear body
                2, 3, 5, // tail top
                3, 4, 5 // tail fin
            ]);

            // eye vertex
            eye_vertex = new Float32Array([0.2, 0.2, 0.0]);
            if (direction == -1) {
                eye_vertex = new Float32Array([0.2, -0.2, 0.0]);
            }

            v_buffer = gl.createBuffer(); // create
            gl.bindBuffer(gl.ARRAY_BUFFER, v_buffer); // bind
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); // put data in
            gl.bindBuffer(gl.ARRAY_BUFFER, null); // unbind

            i_buffer = gl.createBuffer(); // create
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, i_buffer); // bind
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW); // put data in
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); // unbind

            eye_v_buffer = gl.createBuffer(); // create
            gl.bindBuffer(gl.ARRAY_BUFFER, eye_v_buffer); // bind
            gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW); // put data in
            gl.bindBuffer(gl.ARRAY_BUFFER, null ); // unbind

            return [v_buffer, i_buffer, eye_v_buffer, offset, color, scale, direction];
        };

        var step_x = .01;
        var step_y = .01;
        var direction = -1;

        function animate() {
            requestAnimationFrame(animate);

            gl.clearColor(0., 0., 0., 0.)
            gl.clear(gl.COLOR_BUFFER_BIT);

            // enable blending for transparency
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.DEPTH_TEST);

            // update big fish position based on keyboard input
            const margin = 0.1;
            if (keys['w']) {
                bigFishOffset[1] += moveSpeed;
                if (bigFishOffset[1] > 1 - margin) bigFishOffset[1] = 1 - margin;
            }
            if (keys['s']) {
                bigFishOffset[1] -= moveSpeed;
                if (bigFishOffset[1] < -1 + margin) bigFishOffset[1] = -1 + margin;
            }
            if (keys['a']) {
                bigFishOffset[0] -= moveSpeed;
                if (bigFishOffset[0] < -1 + margin) bigFishOffset[0] = -1 + margin;
            }
            if (keys['d']) {
                bigFishOffset[0] += moveSpeed;
                if (bigFishOffset[0] > 1 - margin) bigFishOffset[0] = 1 - margin;
            }
            if (keys['q']) {
                bigFishRotation += rotationSpeed;
            }
            if (keys['e']) {
                bigFishRotation -= rotationSpeed;
            }

            // update big fish color gradually
            for (let i = 0; i < 3; i++) {
                bigFishCurrentColor[i] += (bigFishTargetColor[i] - bigFishCurrentColor[i]) * colorChangeSpeed;
            }
            if (Math.abs(bigFishCurrentColor[0] - bigFishTargetColor[0]) < 0.01 &&
                Math.abs(bigFishCurrentColor[1] - bigFishTargetColor[1]) < 0.01 &&
                Math.abs(bigFishCurrentColor[2] - bigFishTargetColor[2]) < 0.01) {
                bigFishTargetColor = [Math.random(), Math.random(), Math.random(), 0.7];
            }

            for (var r = 0; r < all_fish.length; r++) {
                // current_buffers is a list of [v_buffer, i_buffer]-pairs
                var current_buffers = all_fish[r];
                var current_v_buffer = current_buffers[0];
                var current_i_buffer = current_buffers[1];
                var current_eye_v_buffer = current_buffers[2];
                var current_offset = current_buffers[3];
                var current_color = current_buffers[4];
                var current_scale = current_buffers[5];
                var current_direction = current_buffers[6];

                current_offset[0] += 0.01;
                current_offset[1] += 0.1 * Math.random();
                current_offset[1] -= 0.1 * Math.random();

                if (current_offset[0] >= 1) {
                    current_direction = -1;
                }
                current_offset[0] *= current_direction;

                //************************************************************//
                //
                // CONNECT SHADER WITH GEOMETRY
                //
                gl.bindBuffer(gl.ARRAY_BUFFER, current_v_buffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, current_i_buffer);

                // find the attribute in the shader source
                var a_position = gl.getAttribLocation(shaderprogram, 'a_position');
                gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(a_position);

                // find the uniform in the shader source
                var u_transform = gl.getUniformLocation(shaderprogram, 'u_transform');
                if (r == 0) {
                    // big fish 
                    cosR = Math.cos(bigFishRotation);
                    sinR = Math.sin(bigFishRotation);

                    let transform = [current_direction * current_scale * cosR, current_scale * sinR, 0, 0,
                                    -sinR * current_scale, current_direction * current_scale * cosR, 0, 0,
                                    0, 0, current_scale, 0,
                                    bigFishOffset[0], bigFishOffset[1], 0, 1];

                    gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform));
                } else {
                    // small fish
                    theta = Math.random() * 10 * Math.PI / 180;
                    var transform = [current_direction * current_scale * Math.cos(theta), Math.sin(theta), 0, 0,
                                    -Math.sin(theta), current_direction * current_scale * Math.cos(theta), 0, 0,
                                    0, 0, current_direction * current_scale * 1, 0,
                                    current_offset[0], current_offset[1], current_offset[2], 1];

                    gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform));
                }

                var u_color = gl.getUniformLocation(shaderprogram, 'u_color');
                if (r == 0) {
                    // gradually changing big fish color
                    gl.uniform4fv(u_color, new Float32Array(bigFishCurrentColor));
                } else {
                    // small fish keep dynamic ocean colors
                    t = performance.now() * 0.001;
                    a = 0.6 + 0.4 * Math.sin(t * 2.0);

                    current_color = new Float32Array([
                        0.3 + 0.2 * Math.sin(t + 0.0),
                        0.6 + 0.2 * Math.sin(t + 2.0),
                        0.9 + 0.1 * Math.sin(t + 4.0),
                        a]);

                    gl.uniform4fv(u_color, current_color);
                }

                //************************************************************//
                //
                // DRAW!
                //
                gl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);
                
                //************************************************************//
                //
                // DRAW EYE
                //
                gl.uniform4fv(u_color, new Float32Array([0., 0., 0., 0.5]));

                // set dynamic point size based on current scale
                var u_pointSize = gl.getUniformLocation(shaderprogram, 'u_pointSize');
                gl.uniform1fv(u_pointSize, new Float32Array([current_scale * 20.]));

                // bind and draw the eye
                gl.bindBuffer(gl.ARRAY_BUFFER, current_eye_v_buffer);
                gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(a_position);
                gl.drawArrays(gl.POINTS, 0, 1);
            }
        };
    </script>

    <body>
        <audio id="bgm" src="underwater_sound_effect.mp3" autoplay loop></audio>
        <canvas id="c"></canvas>

        <div id="music-toggle">
            ðŸŽµ
        </div>

        <button id="goback-btn">Go Back</button>
    </body>
</html>